---
description: 
globs: server/YellowHouseStudio.LifeOrbit.Tests.Integration/**/*Tests.cs
alwaysApply: false
---
# Backend Integration Testing Guidelines (Gold Standard)

## Overview
These standards are based on the actual practices implemented in the LifeOrbit codebase, using `AddAllergyCommand` and `RemoveAllergyCommand` integration tests as the gold standard. See:
- [AddAllergyCommandHandlerTests.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Integration/Application/Family/AddAllergy/AddAllergyCommandHandlerTests.cs)
- [RemoveAllergyCommandHandlerTests.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Integration/Application/Family/RemoveAllergy/RemoveAllergyCommandHandlerTests.cs)

## General Principles
- Use NUnit for all test classes (`[TestFixture]`, `[Test]`, `[SetUp]`)
- Use FluentAssertions for all assertions
- Use the Arrange-Act-Assert (AAA) pattern in every test
- Use the Builder pattern for commands and domain objects (see `AddAllergyCommandBuilder`, `FamilyMemberBuilder`)
- Cover both positive (happy path) and negative (error/edge) cases
- Use meaningful, explicit test data
- Each test should be isolated and not depend on shared state

## Test Class Structure
- Test classes should be named `{TypeUnderTest}Tests.cs`
- Place integration tests in `Tests.Integration/Application/...`
- Inherit from [TestBase.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Integration/TestBase.cs)
- Use `[SetUp]` for per-test initialization

## Test Method Naming
- Use descriptive, scenario-based names:
  - `<MethodName>_<scenario>_<expected_outcome>()`
- Use async Task for all tests that perform async operations

## Builder Pattern
- Use test data builders for commands and domain objects to keep tests readable and maintainable
- Example: [AddAllergyCommandBuilder.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Common/Builders/AddAllergyCommandBuilder.cs)
- Example: [FamilyMemberBuilder.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Common/Builders/FamilyMemberBuilder.cs)

## Assertion Practices
- Use FluentAssertions for all assertions:
  ```csharp
  result.Should().NotBeNull();
  result.Allergies.Should().BeEmpty();
  await FluentActions.Invoking(() => Mediator.Send(command, CancellationToken.None))
      .Should().ThrowAsync<ValidationException>()
      .WithMessage("*Family member not found*");
  ```
- Prefer one main assertion per test, but group related assertions if they are part of the same scenario

## Coverage Requirements
- Cover all validation rules (required, length, format, existence, business rules)
- Test both valid and invalid scenarios
- Test edge cases (empty, null, max/min values, invalid references, duplicates, etc.)
- Verify both direct results and database state

## Example Test Pattern
```csharp
[Test]
public async Task RemoveAllergy_removes_allergy_successfully()
{
    // Arrange
    var command = new RemoveAllergyCommand { FamilyMemberId = _familyMemberId, Allergen = _allergen };

    // Act
    var result = await Mediator.Send(command, CancellationToken.None);

    // Assert
    result.Allergies.Should().BeEmpty();
    var member = await Context.FamilyMembers.Include(fm => fm.Allergies).FirstAsync(fm => fm.Id == _familyMemberId);
    member.Allergies.Should().BeEmpty();
}
```

## Best Practices Checklist
- [ ] Use test data builders for all complex objects/commands
- [ ] Use FluentAssertions for all assertions
- [ ] Use Arrange-Act-Assert in every test
- [ ] Cover both positive and negative scenarios
- [ ] Use descriptive, scenario-based test names
- [ ] Keep tests isolated and repeatable
- [ ] Reference gold standard tests for new features
