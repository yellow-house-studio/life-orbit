---
description: 
globs: server/**/*Validator.cs,server/**/*ValidatorTests.cs
alwaysApply: false
---
# Validator Best Practices (Gold Standard)

## Overview
These standards are based on the actual practices implemented in the LifeOrbit codebase, using `AddAllergyCommand` and `RemoveAllergyCommand` validator tests as the gold standard. See:
- [AddAllergyCommandValidatorTests.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Unit/Application/Family/AddAllergy/AddAllergyCommandValidatorTests.cs)
- [RemoveAllergyCommandValidatorTests.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Unit/Application/Family/RemoveAllergy/RemoveAllergyCommandValidatorTests.cs)

## General Principles
- Use FluentValidation for all validators
- Use NUnit for all test classes (`[TestFixture]`, `[Test]`, `[SetUp]`)
- Use FluentAssertions for all assertions
- Use the Arrange-Act-Assert (AAA) pattern in every test
- Use the Builder pattern for commands and domain objects (see `AddAllergyCommandBuilder`, `FamilyMemberBuilder`)
- Mock dependencies with Moq for unit tests
- Cover both positive (happy path) and negative (error/edge) cases
- Use meaningful, explicit test data
- Each test should be isolated and not depend on shared state

## Test Class Structure
- Test classes should be named `{TypeUnderTest}Tests.cs`
- Place validator tests in `Tests.Unit/Application/...`
- Use `[SetUp]` for per-test initialization

## Test Method Naming
- Use descriptive, scenario-based names:
  - `Should_<expected_behavior>_when_<condition>()`
- Use async Task for all tests that perform async operations

## Builder Pattern
- Use test data builders for commands and domain objects to keep tests readable and maintainable
- Example: [AddAllergyCommandBuilder.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Common/Builders/AddAllergyCommandBuilder.cs)
- Example: [FamilyMemberBuilder.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Common/Builders/FamilyMemberBuilder.cs)

## Assertion Practices
- Use FluentAssertions for all assertions:
  ```csharp
  result.Should().BeTrue();
  result.ShouldHaveValidationErrorFor(x => x.Allergen)
      .WithErrorMessage("Please enter an allergen");
  result.Errors.Should().Contain(e => e.PropertyName == "Allergen");
  ```
- Prefer one main assertion per test, but group related assertions if they are part of the same scenario

## Mocking and Isolation
- Use Moq for mocking dependencies (e.g., repositories, user context)
- Setup mocks explicitly for each test scenario
- Do not share state between tests

## Coverage Requirements
- Cover all validation rules (required, length, format, existence, business rules)
- Test both valid and invalid scenarios
- Test edge cases (empty, null, max/min values, invalid references, duplicates, etc.)
- For validators, check error messages and error codes

## Example Test Pattern
```csharp
[Test]
public async Task Validator_have_error_when_Allergen_is_empty()
{
    var command = new AddAllergyCommand { Allergen = string.Empty };
    var result = await _validator.TestValidateAsync(command);
    result.ShouldHaveValidationErrorFor(x => x.Allergen)
        .WithErrorMessage("Please enter an allergen");
}
```

## Best Practices Checklist
- [ ] Use test data builders for all complex objects/commands
- [ ] Use FluentAssertions for all assertions
- [ ] Use Arrange-Act-Assert in every test
- [ ] Mock all external dependencies in unit tests
- [ ] Cover both positive and negative scenarios
- [ ] Use descriptive, scenario-based test names
- [ ] Keep tests isolated and repeatable
- [ ] Reference gold standard tests for new features

## Key Principles
- Validators should be implemented using FluentValidation.
- All validation logic for a command/query should reside in its dedicated validator class.
- Use dependency injection for repository and user context dependencies.
- Use `WithErrorCode` to provide meaningful error codes (e.g., `ValidationErrorCodes.NotFound`) for mapping to HTTP status codes. Defaults to BadRequest (regular validation error)
- Validation should cover:
  - Required fields (e.g., not empty, not null)
  - Field length and format constraints
  - Existence and ownership of referenced entities
  - Business rules (e.g., uniqueness, allowed values)
- Use clear, user-friendly error messages for each rule.
- Prefer async validation for database or external checks.

## Example: AddAllergyCommandValidator
See [AddAllergyCommandValidator.cs](mdc:server/YellowHouseStudio.LifeOrbit.Application/Family/AddAllergy/AddAllergyCommandValidator.cs) for a comprehensive example:
- Checks for required fields and valid enum values
- Verifies existence and ownership of the family member
- Ensures allergen is not already registered
- Uses `WithErrorCode(ValidationErrorCodes.NotFound)` for not found scenarios

## Example: RemoveAllergyCommandValidator
See [RemoveAllergyCommandValidator.cs](mdc:server/YellowHouseStudio.LifeOrbit.Application/Family/RemoveAllergy/RemoveAllergyCommandValidator.cs):
- Checks for required fields and max length
- Verifies existence and ownership of the family member
- Ensures the allergy is present before removal
- Uses `WithErrorCode(ValidationErrorCodes.NotFound)` for not found scenarios

## Unit Testing Requirements
- Every validator must have a corresponding unit test class.
- Unit tests must cover:
  - All validation rules (required, length, format, existence, business rules)
  - Edge cases (empty, null, max/min values, invalid references, etc.)
  - Both valid and invalid scenarios
- Use mocks for repository and user context dependencies.
- Example test class: [RemoveAllergyCommandValidatorTests.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Unit/Application/Family/RemoveAllergy/RemoveAllergyCommandValidatorTests.cs)

## Good Practices
- Keep validators focused and readable; group related rules together.
- Use descriptive error messages and error codes for all rules.
- Prefer async rules for checks that require I/O or database access.
- Avoid business logic in validatorsâ€”only enforce input and existence/ownership rules.
- Ensure all validation rules are covered by unit tests, including edge and negative cases.

## References
- [AddAllergyCommandValidator.cs](mdc:server/YellowHouseStudio.LifeOrbit.Application/Family/AddAllergy/AddAllergyCommandValidator.cs)
- [RemoveAllergyCommandValidator.cs](mdc:server/YellowHouseStudio.LifeOrbit.Application/Family/RemoveAllergy/RemoveAllergyCommandValidator.cs)
- [RemoveAllergyCommandValidatorTests.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Unit/Application/Family/RemoveAllergy/RemoveAllergyCommandValidatorTests.cs)
