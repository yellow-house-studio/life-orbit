---
description: 
globs: *Tests.cs
alwaysApply: false
---
# Backend Testing Standards (Gold Standard)

## Overview
These standards are based on the actual practices implemented in the LifeOrbit codebase, using `AddAllergyCommand` and `RemoveAllergyCommand` tests as the gold standard. See:
- [AddAllergyCommandValidatorTests.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Unit/Application/Family/AddAllergy/AddAllergyCommandValidatorTests.cs)
- [RemoveAllergyCommandValidatorTests.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Unit/Application/Family/RemoveAllergy/RemoveAllergyCommandValidatorTests.cs)
- [FamilyAllergiesControllerTests.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.API/Controllers/FamilyAllergiesControllerTests.cs)

## General Principles
- Use NUnit for all test classes (`[TestFixture]`, `[Test]`, `[SetUp]`)
- Use FluentAssertions for all assertions
- Use the Arrange-Act-Assert (AAA) pattern in every test
- Use the Builder pattern for commands and domain objects (see `AddAllergyCommandBuilder`, `FamilyMemberBuilder`)
- Mock dependencies with Moq for unit tests
- Cover both positive (happy path) and negative (error/edge) cases
- Use meaningful, explicit test data
- Each test should be isolated and not depend on shared state

## Test Class Structure
- Test classes should be named `{TypeUnderTest}Tests.cs`
- Place validator tests in `Tests.Unit/Application/...`
- Place API/controller tests in `Tests.API/Controllers/...`
- Use `[SetUp]` for per-test initialization
- Use `[TearDown]` only if cleanup is required

## Test Method Naming
- Use descriptive, scenario-based names:
  - For unit tests: `Method_<expected_behavior>_when_<condition>()`
  - For API/integration: `<Action>_<scenario>_<expected_result>()`
- Use async Task for all tests that perform async operations

## Builder Pattern
- Use test data builders for commands and domain objects to keep tests readable and maintainable
- Example: [AddAllergyCommandBuilder.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Common/Builders/AddAllergyCommandBuilder.cs)
- Example: [FamilyMemberBuilder.cs](mdc:server/YellowHouseStudio.LifeOrbit.Tests.Common/Builders/FamilyMemberBuilder.cs)

## Assertion Practices
- Use FluentAssertions for all assertions:
  ```csharp
  result.Should().BeTrue();
  response.StatusCode.Should().Be(HttpStatusCode.OK);
  result.Errors.Should().Contain(e => e.PropertyName == "Allergen");
  ```
- Prefer one main assertion per test, but group related assertions if they are part of the same scenario

## Mocking and Isolation
- Use Moq for mocking dependencies (e.g., repositories, user context)
- Setup mocks explicitly for each test scenario
- Do not share state between tests

## Coverage Requirements
- Cover all validation rules (required, length, format, existence, business rules)
- Test both valid and invalid scenarios
- Test edge cases (empty, null, max/min values, invalid references, duplicates, etc.)
- For API tests, verify both HTTP status codes and response content
- For validators, check error messages and error codes

## Example Test Patterns
```csharp
[Test]
public async Task Validator_have_error_when_Allergen_is_empty()
{
    var command = new AddAllergyCommand { Allergen = string.Empty };
    var result = await _validator.TestValidateAsync(command);
    result.ShouldHaveValidationErrorFor(x => x.Allergen)
        .WithErrorMessage("Please enter an allergen");
}

[Test]
public async Task AddAllergy_returns_bad_request_for_empty_allergen()
{
    var command = new AddAllergyCommandBuilder()
        .WithFamilyMemberId(_familyMemberId)
        .WithAllergen(string.Empty)
        .WithSeverity(AllergySeverity.NotAllowed)
        .Build();
    var response = await Client.PostAsJsonAsync($"settings/family/{_familyMemberId}/allergies", command);
    response.StatusCode.Should().Be(HttpStatusCode.BadRequest);
    var error = await response.Content.ReadAsStringAsync();
    error.Should().Contain("Please enter an allergen");
}
```

## Project Structure
```
YellowHouseStudio.LifeOrbit.Tests.Unit/
├── Application/
│   └── Family/
│       ├── AddAllergy/
│       │   └── AddAllergyCommandValidatorTests.cs
│       └── RemoveAllergy/
│           └── RemoveAllergyCommandValidatorTests.cs
└── ...
YellowHouseStudio.LifeOrbit.Tests.API/
└── Controllers/
    └── FamilyAllergiesControllerTests.cs
```

## Best Practices Checklist
- [ ] Use test data builders for all complex objects/commands
- [ ] Use FluentAssertions for all assertions
- [ ] Use Arrange-Act-Assert in every test
- [ ] Mock all external dependencies in unit tests
- [ ] Cover both positive and negative scenarios
- [ ] Use descriptive, scenario-based test names
- [ ] Keep tests isolated and repeatable
- [ ] Reference gold standard tests for new features

## Domain Model Testing

### Class Structure
- Each domain model should have a corresponding test class in the `Tests.Unit` project
- Test classes should follow the pattern: `{ModelName}Tests.cs`
- Reference implementation: [FamilyMember.cs](mdc:server/YellowHouseStudio.LifeOrbit.Domain/Family/FamilyMember.cs)

### NUnit Conventions
- Use `[TestFixture]` attribute for test classes
- Use `[Test]` attribute for test methods
- Use `[SetUp]` for common test initialization
- Use `[TearDown]` for cleanup if needed
- Use `[TestCase]` for parameterized tests
- Example assertions:
  ```csharp
  Assert.That(result.Name, Is.EqualTo("Expected"));
  Assert.That(result.Age, Is.GreaterThan(0));
  Assert.That(result.Allergies, Is.Empty);
  Assert.That(result.Id, Is.Not.EqualTo(Guid.Empty));
  ```

### Test Organization
1. Constructor Tests
   - Test initialization with valid parameters
   - Verify all properties are set correctly
   - Ensure Guid.NewGuid() is called for Id properties

2. Property Tests
   - Verify private setters are working
   - Test collection properties are initialized as empty lists
   - Ensure non-nullable string properties are initialized as string.Empty

3. Method Tests
   - Test both success and edge cases
   - Verify state changes
   - Test collection modifications (Add/Remove operations)
   - Test update operations

### Test Naming Convention
- Pattern: `MethodName_action_subject_condition`
- Use lowercase with underscores
- Start with the method name being tested
- Describe what the method does (active voice)
- Include the subject and condition if relevant
- Examples:
```csharp
public void Constructor_creates_family_member_with_valid_properties()
{
    // Arrange
    // Act
    // Assert
}

public void AddAllergy_adds_new_allergy_to_empty_list()
{
    // Arrange
    // Act
    // Assert
}

public void UpdateStatus_updates_existing_preference_with_new_status()
{
    // Arrange
    // Act
    // Assert
}
```

### Value Object Testing
- Test equality comparisons
- Test immutability
- Test validation rules
- Example: [Allergy.cs](mdc:server/YellowHouseStudio.LifeOrbit.Domain/Family/Allergy.cs)

### Collection Property Rules
- Test Add operations
- Test Remove operations
- Test duplicate handling
- Test empty/null cases
- Reference: [FamilyMember.cs](mdc:server/YellowHouseStudio.LifeOrbit.Domain/Family/FamilyMember.cs) Allergies, SafeFoods, and FoodPreferences properties

### Enum Testing
- Test all enum values are handled
- Test invalid enum values
- Examples: 
  - [AllergySeverity](mdc:server/YellowHouseStudio.LifeOrbit.Domain/Family/Allergy.cs)
  - [PreferenceStatus](mdc:server/YellowHouseStudio.LifeOrbit.Domain/Family/FoodPreference.cs)

## Test Project Structure
```
YellowHouseStudio.LifeOrbit.Tests.Unit/
├── Domain/
│   └── Family/
│       ├── AllergyTests.cs
│       ├── FamilyMemberTests.cs
│       ├── FoodPreferenceTests.cs
│       └── SafeFoodTests.cs
├── Application/
│   └── Services/
└── Infrastructure/
    └── Repositories/
```

## Testing Guidelines
1. Use meaningful test data
2. One assertion per test when possible
3. Test both positive and negative cases
4. Ensure proper isolation between tests
5. No external dependencies in unit tests
6. Follow AAA pattern (Arrange-Act-Assert)
7. Test null handling where appropriate
8. Test boundary conditions

## Domain Rules
- All domain entities must have private setters
- Collections should be initialized in constructor
- Non-nullable properties must have default values
- Use appropriate access modifiers
- Domain logic should be encapsulated within the entity